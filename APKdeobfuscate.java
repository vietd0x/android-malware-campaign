public class MainActivity extends AppCompatActivity {
    public static int dec1_flag(int i) {
        int i2 = 190583926;

        while (true) {
            i2 ^= 190583934;
            if (0 == 0) {
                return i2;
            }
        }
    }

    public static int dec2_flag(int i, int i2) {
        int i3 = 1852906446;
        while (true) {
            i3 ^= 1852906438;
            if (0 == 0) {
                return i3;
            }
        }
    }

    public static String dec0(String str){
        byte[] decode = Base64.decode(str.getBytes(StandardCharsets.UTF_8), 8);
        for(int i = 0; i < decode.length; i++){
            decode[i] = (byte) (decode[i] ^ 4);
        }
        return new String(decode, StandardCharsets.UTF_8);
    }

    public static String dec1(String str){
        byte[] decode = Base64.decode(str.getBytes(StandardCharsets.UTF_8), dec1_flag(384716));
        for(int i = 0; i < decode.length; i++){
            decode[i] = (byte) (decode[i] ^ 109);
        }
        return new String(decode, StandardCharsets.UTF_8);
    }

    public static String dec2(String str) {
        byte[] decode = Base64.decode(str.getBytes(StandardCharsets.UTF_8),  dec2_flag(816405, 816405));
        for (int i = 0; i < decode.length; i++) {
            decode[i] = (byte) (decode[i] ^ 87);
        }
        return new String(decode, StandardCharsets.UTF_8);
    }


    static private  String outFile = "/data/local/tmp/out.java";
    static private String inFile = "/data/local/tmp/00000001.java";
    static private String classFile = "/data/local/tmp/class_tmp.java";
    static String p012 = "cxn.dec2\\(ri4.dec1\\(br8pxf.dec0\\(\"([a-zA-Z0-9,-]+)\"\\)\\)\\)";
    static String p0 = "br8pxf.dec0\\(\"([a-zA-Z0-9,-]+)\"\\)";
    static String funcName_r = "public static int ([a-z]+)\\(.*\\{";

    private static String Dec012(String line, String patt){
        Pattern r = Pattern.compile(patt);
        Matcher m = r.matcher(line);

        String s = "";
        int curidx = 0;
        while (m.find()) {
            s += line.substring(curidx, m.start());
            curidx += (m.start()-curidx);
            s += "\"" + dec2(dec1(dec0(m.group(1)))) + "\"";
            curidx += m.group(0).length();
        }
        s += line.substring(curidx, line.length());

        return s;

    }

    private static String Dec0(String line, String patt){
        Pattern r = Pattern.compile(patt);
        Matcher m = r.matcher(line);

        String s = "";
        int curidx = 0;
        while (m.find()) {
            s += line.substring(curidx, m.start());
            curidx += (m.start()-curidx);
            s += "\"" + dec0(m.group(1)) + "\"";
            curidx += m.group(0).length();
        }
        s += line.substring(curidx, line.length());
        return s;
    }

    private static Object convertToType(String value, Class<?> targetType) {
        if (targetType == int.class || targetType == Integer.class) {
            return Integer.parseInt(value);
        } else if (targetType == double.class || targetType == Double.class) {
            return Double.parseDouble(value);
        } else if (targetType == String.class) {
            return value;
        }
        // Add more cases for other parameter types as needed

        throw new IllegalArgumentException("Unsupported parameter type: " + targetType);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // after we have class_tmp file

        // load the class
        Class<?> anotherClass = null;
        try {
            anotherClass = Class.forName("com.example.myapplication.class_tmp");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
        Object instance = null;
        try {
            instance = anotherClass.getDeclaredConstructor().newInstance();
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }

        Method[] methods = anotherClass.getMethods();

        try{
            // create new outFile & classFile
            FileWriter fw  = new FileWriter(outFile, false);
            FileWriter classf = new FileWriter(classFile, false);

            BufferedWriter bw = new BufferedWriter(fw);
            BufferedWriter class_bw = new BufferedWriter(classf);

            File Obj = new File(inFile);
            Scanner Reader = new Scanner(Obj);

            // stored funtionName and result
            Map<String, String> FuncName_code = new HashMap<>();
            String tmpKey = "";
            StringBuilder func_code = new StringBuilder();
            int openBraces = 0;
            int closeBraces = 0;

            // 1 read each line in src file
            while (Reader.hasNextLine()) {
                String line = Reader.nextLine();
                // 2 . if line has decrypt function
                String s ="";

                if(!tmpKey.equals("")){
                    // append line of code
                    func_code.append(line + "\n");

                    // add curlyBraces
                    openBraces += line.length() - line.replace("{", "").length();
                    closeBraces += line.length() - line.replace("}", "").length();

                    if(openBraces == closeBraces){ //function end
                        FuncName_code.put(tmpKey, func_code.toString());

                        // Write to the class file
                        class_bw.write(func_code.toString());

                        // clear funcName & code for next function
                        tmpKey = "";
                        func_code.delete(0, func_code.length());
                    }
                }

                if(line.contains("public static int")){
                    Pattern r = Pattern.compile(funcName_r);
                    Matcher m = r.matcher(line);
                    if(m.find()){
                        // get function name into hashMap
                        tmpKey = line.trim().split(" ")[3]; // get funcName
                        openBraces += 1;
                        func_code.append(line + "\n");
                    }
                }



                // check line call function from class_tmp
                // find all func appear on line
                String regFuncCall = "([a-z]+)\\(([\\d, ]+)\\)";
                Pattern r_regFuncCall = Pattern.compile(regFuncCall);
                Matcher m_regFuncCall = r_regFuncCall.matcher(line);
                while(m_regFuncCall.find()){
                    for (Method method : methods) {
                        String methodName = method.getName();
                        if (methodName.equals(m_regFuncCall.group(1))) {
                            // get params from line
                            String[] paramValues = m_regFuncCall.group(2).split(",");
                            Object[] convertedParams = new Object[paramValues.length];

                            // Extract parameter types from the method
                            Class<?>[] parameterTypes = method.getParameterTypes();
                            for (int i = 0; i < parameterTypes.length; i++) {
                                convertedParams[i] = convertToType(paramValues[i].trim(), parameterTypes[i]);
                            }

                            // invoke the method & get result
                            Object res = method.invoke(instance, convertedParams);
                            String group0 = m_regFuncCall.group(0);
                            line = line.substring(0, line.indexOf(group0)) + res + line.substring(line.indexOf(group0) + group0.length(), line.length());
                        }
                    }
                }



                if(line.contains("cxn.dec2(ri4.dec1(br8pxf.dec0")){
                    // 3. update decrypt line in to new file, else update orig line
                     line = Dec012(line, p012);
                }
                bw.write(line); bw.write(System.lineSeparator());


            }
            class_bw.close();
            bw.close();
            Reader.close();
            fw.close();
            classf.close();

        }catch (Exception e){
            System.out.println("An error has occurred.");
            System.err.println(e);
            e.printStackTrace();
        }
    }
}
